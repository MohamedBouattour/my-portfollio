<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide Authentification React</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
    <style>
        body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }
        @media (max-width: 767px) {
            body {
                padding: 15px;
            }
        }
        .mermaid {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
    </style>
</head>
<body class="markdown-body">
<h1 id="guidedimplmentationauthentificationetroutesimbriques">Guide d'Impl√©mentation : Authentification et Routes Imbriqu√©es</h1>
<p>Ce guide vous explique comment ajouter une fonctionnalit√© de connexion s√©curis√©e √† votre application React en utilisant <code>Context</code>, des <code>Hooks</code> personnalis√©s et <code>React Router</code>.</p>
<h2 id="objectifs">Objectifs üéØ</h2>
<ol>
<li>G√©rer l'√©tat de l'utilisateur (connect√©/d√©connect√©) globalement avec <strong>Context</strong>.</li>
<li>Cr√©er un <strong>Hook personnalis√©</strong> <code>useAuth</code> pour simplifier l'acc√®s aux donn√©es.</li>
<li>Prot√©ger les routes d'administration via un composant wrapper.</li>
<li>Ma√Ætriser les Hooks avanc√©s : <code>useParams</code>, <code>useEffect</code>, <code>useRef</code>.</li>
</ol>
<hr />
<h2 id="vuedensemble">Vue d'Ensemble üó∫Ô∏è</h2>
<p>Voici comment les composants interagissent entre eux :</p>
<pre><code class="mermaid language-mermaid">graph TD
    A[AuthProvider] --&gt;|Fournit Contexte| B[App]
    B --&gt; C[Routes]
    C --&gt; D[Public Routes]
    C --&gt; E[Protected Routes]
    E --&gt;|V√©rifie Auth| F[ProtectedRoute]
    F --&gt;|Si Admin| G[Admin Pages]
    F --&gt;|Si Non Connect√©| H[Login Page]
    G --&gt; I[Project Details]

    subgraph Data Flow
    J[useAuth] --&gt;|Consomme| A
    G --&gt;|Utilise| J
    H --&gt;|Modifie| J
    end
</code></pre>
<hr />
<h2 id="partie1authentificationsimplifiesrccontextauthcontexttsx">Partie 1 : Authentification Simplifi√©e (<code>src/context/AuthContext.tsx</code>)</h2>
<p>Nous utilisons un seul fichier pour tout g√©rer.</p>
<pre><code class="tsx language-tsx">import { createContext, useState, useEffect, useContext } from 'react';
import type { ReactNode } from 'react';

// ... (Code identique au pr√©c√©dent pour AuthContext)
</code></pre>
<p><em>(Voir votre code source pour l'impl√©mentation compl√®te)</em></p>
<hr />
<h2 id="partie2conceptsavancs">Partie 2 : Concepts Avanc√©s üöÄ</h2>
<h3 id="1routesdynamiquesavecuseparams">1. Routes Dynamiques avec <code>useParams</code></h3>
<p>Pour cr√©er une page de d√©tail (ex: <code>/admin/projects/123</code>), on utilise <code>useParams</code>.</p>
<p><strong>Configuration Route (<code>App.tsx</code>)</strong> :</p>
<pre><code class="tsx language-tsx">&lt;Route path="projects/:id" element={&lt;AdminProjectDetails /&gt;} /&gt;
</code></pre>
<p><strong>R√©cup√©ration ID (<code>AdminProjectDetails.tsx</code>)</strong> :</p>
<pre><code class="tsx language-tsx">import { useParams } from 'react-router-dom';

export default function AdminProjectDetails() {
  const { id } = useParams(); // id vaudra "123"
  // ...
}
</code></pre>
<h3 id="2lecycledevieavecuseeffect">2. Le Cycle de Vie avec <code>useEffect</code></h3>
<p>Ce hook permet d'effectuer des actions √† des moments pr√©cis.</p>
<ul>
<li><strong>Au montage seulement</strong> (Comme <code>componentDidMount</code>) :</li>
</ul>
<pre><code class="tsx language-tsx">useEffect(() =&gt; {
  console.log("Composant affich√© !");
  fetchData();
}, []); // Tableau vide
</code></pre>
<ul>
<li><strong>Quand une variable change</strong> :</li>
</ul>
<pre><code class="tsx language-tsx">useEffect(() =&gt; {
  console.log("ID a chang√© :", id);
}, [id]); // Se relance si 'id' change
</code></pre>
<ul>
<li><strong>√Ä chaque rendu</strong> (Attention aux performances !) :</li>
</ul>
<pre><code class="tsx language-tsx">useEffect(() =&gt; {
  console.log("Rendu !");
}); // Pas de tableau
</code></pre>
<ul>
<li><strong>Nettoyage</strong> (Comme <code>componentWillUnmount</code>) :</li>
</ul>
<pre><code class="tsx language-tsx">useEffect(() =&gt; {
  return () =&gt; {
    console.log("Composant d√©truit");
    // Annuler des abonnements ici
  };
}, []);
</code></pre>
<h3 id="3rfrencesavecuseref">3. R√©f√©rences avec <code>useRef</code></h3>
<p><code>useRef</code> a deux utilit√©s principales :</p>
<ol>
<li><strong>Acc√©der au DOM</strong> (ex: mettre le focus sur un input).</li>
<li><strong>Stocker une valeur mutable</strong> qui ne provoque pas de re-render quand on la change.</li>
</ol>
<pre><code class="tsx language-tsx">const inputRef = useRef&lt;HTMLInputElement&gt;(null);

// Mettre le focus au chargement
useEffect(() =&gt; {
   if(inputRef.current) inputRef.current.focus();
}, []);

return &lt;input ref={inputRef} /&gt;;
</code></pre>
<hr />
<h2 id="partie3architectureapibonnespratiques">Partie 3 : Architecture API &amp; Bonnes Pratiques üõ†Ô∏è</h2>
<p>Pour garder le code propre, il est crucial de ne pas faire les appels <code>fetch</code> directement dans les composants.</p>
<h3 id="architecturerecommande">Architecture Recommand√©e</h3>
<p>Nous avons cr√©√© un guide d√©taill√© sur l'architecture API ici : <a href="./API_BEST_PRACTICES.md">API_BEST_PRACTICES.md</a>.</p>
<p><strong>En r√©sum√© :</strong></p>
<ol>
<li><strong>Services</strong> : Tous les appels API sont dans <code>src/services/</code>.</li>
<li><strong>Types</strong> : Les interfaces TypeScript sont dans <code>src/types/</code>.</li>
<li><strong>Token</strong> : Le token est g√©r√© automatiquement par le wrapper <code>api.ts</code>.</li>
<li><strong>Gestion d'erreur</strong> : Centralis√©e pour √©viter de r√©p√©ter les <code>try/catch</code>.</li>
</ol>
<p>Exemple d'utilisation avec le nouveau service :</p>
<pre><code class="tsx language-tsx">import { ProjectService } from '../services/project.service';

// Dans votre composant
useEffect(() =&gt; {
  ProjectService.getAll().then(data =&gt; setProjects(data));
}, []);
</code></pre>
<hr />
<hr />
<h2 id="partie4comprendrelejwtjsonwebtoken">Partie 4 : Comprendre le JWT (JSON Web Token) üîë</h2>
<p>Le <strong>JWT</strong> est un standard pour √©changer des informations de mani√®re s√©curis√©e.
Il est compos√© de 3 parties s√©par√©es par des points (<code>.</code>) :</p>
<ol>
<li><strong>Header</strong> : L'algo de cryptage (ex: HS256).</li>
<li><strong>Payload</strong> : Les donn√©es de l'utilisateur (id, email, expiration).</li>
<li><strong>Signature</strong> : Assure que le token n'a pas √©t√© modifi√©.</li>
</ol>
<p><strong>Flux d'authentification :</strong></p>
<ol>
<li>L'utilisateur envoie email/password au serveur.</li>
<li>Le serveur v√©rifie et renvoie un <strong>Token</strong> sign√©.</li>
<li>Le client stocke ce Token (localStorage ou Cookie).</li>
<li>Pour chaque requ√™te suivante, le client envoie le Token dans le header <code>Authorization</code>.</li>
</ol>
<h3 id="dcodagectclientsrcutilsjwtts">D√©codage C√¥t√© Client (<code>src/utils/jwt.ts</code>)</h3>
<p>Nous ne pouvons pas v√©rifier la signature (seul le serveur a la cl√© secr√®te), mais nous pouvons <strong>d√©coder</strong> le payload pour afficher le nom ou v√©rifier l'expiration.</p>
<pre><code class="typescript language-typescript">// Exemple de fonction de d√©codage simple (base64)
export function decodeJWT(token) {
  const payload = token.split('.')[1];
  return JSON.parse(atob(payload));
}
</code></pre>
<hr />
<h2 id="partie5webservicesetcrud">Partie 5 : WebServices et CRUD üì°</h2>
<p>Le <strong>CRUD</strong> (Create, Read, Update, Delete) est la base des applications web.</p>
<h3 id="architectureservice">Architecture Service</h3>
<p>Pour √©viter de dupliquer le code <code>fetch</code>, on utilise des <strong>Services</strong>.</p>
<p><strong>Exemple : <code>ProjectService</code></strong></p>
<ul>
<li><strong>GET</strong> (Read) : <code>client.get('/projects')</code></li>
<li><strong>POST</strong> (Create) : <code>client.post('/projects', data)</code></li>
<li><strong>PUT</strong> (Update) : <code>client.put('/projects/${id}', data)</code></li>
<li><strong>DELETE</strong> (Delete) : <code>client.delete('/projects/${id}')</code></li>
</ul>
<h3 id="limportanceducontext">L'importance du Context</h3>
<p>Le <code>Context</code> React sert √† partager des donn√©es "globales" (Auth, Th√®me, Langue) sans passer les props manuellement √† chaque √©tage ("Prop Drilling").</p>
<hr />
<h2 id="partie6lehookuseeffectendtail">Partie 6 : Le Hook useEffect en D√©tail üé£</h2>
<p><code>useEffect</code> synchronise votre composant avec un syst√®me ext√©rieur (API, DOM, Timer).</p>
<h3 id="les4mouvementsduuseeffect">Les 4 Mouvements du useEffect</h3>
<ol>
<li><strong>Mounting (D√©marrage)</strong> : Le tableau de d√©pendances est vide <code>[]</code>.
<em>Exemple : Charger des donn√©es au lancement.</em></li>
<li><strong>Updating (Mise √† jour)</strong> : Le tableau contient des variables <code>[id, user]</code>.
<em>Exemple : Recharger les donn√©es quand l'ID change.</em></li>
<li><strong>Unmounting (Nettoyage)</strong> : La fonction retourne une autre fonction.
<em>Exemple : Couper une connexion WebSocket.</em></li>
<li><strong>No Dependency (Danger)</strong> : Pas de tableau.
<em>S'ex√©cute √† chaque rendu. √Ä √©viter sauf cas rares.</em></li>
</ol>
<pre><code class="typescript language-typescript">useEffect(() =&gt; {
  // 1. Code ex√©cut√© au montage ou update
  const timer = setInterval(() =&gt; console.log('Tic'), 1000);

  // 2. Fonction de nettoyage (ex√©cut√©e avant le prochain effet ou au d√©montage)
  return () =&gt; {
    clearInterval(timer); // Important pour √©viter les fuites de m√©moire !
  };
}, []); // Tableau de d√©pendances
</code></pre>
<hr />
<h2 id="quizdevalidation">Quiz de Validation üß†</h2>
<p><strong>Q1. Quelle partie du JWT contient les donn√©es utilisateur ?</strong>
A) Header
B) Payload
C) Signature</p>
<p><strong>Q2. Que signifie CRUD ?</strong>
A) Create, Read, Update, Delete
B) Code, Run, Unit, Debug
C) Connect, Request, User, Database</p>
<p><strong>Q3. Pourquoi utiliser un Service pour les appels API ?</strong>
A) Pour rendre le code plus lent
B) Pour centraliser la logique et r√©utiliser le code
C) C'est obligatoire par React</p>
<p><strong>Q4. Si je veux ex√©cuter un effet uniquement quand la variable <code>userId</code> change, que dois-je mettre dans le tableau de d√©pendances ?</strong>
A) <code>[]</code>
B) <code>[userId]</code>
C) Rien du tout</p>
<p><strong>Q5. Comment envoyer le token au serveur de mani√®re s√©curis√©e ?</strong>
A) Dans l'URL
B) Dans le header <code>Authorization: Bearer &lt;token&gt;</code>
C) Dans le body de chaque requ√™te</p>
<p><strong>Q6. Que se passe-t-il si on oublie la fonction de nettoyage dans un <code>useEffect</code> qui cr√©e un <code>setInterval</code> ?</strong>
A) Rien de grave
B) Le timer continue de tourner ind√©finiment (fuite de m√©moire)
C) React plante imm√©diatement</p>
<p><strong>Q7. Quelle m√©thode de <code>React Router</code> permet de r√©cup√©rer <code>:id</code> dans l'URL ?</strong>
A) <code>useRoute</code>
B) <code>useParams</code>
C) <code>useHistory</code></p>
<p><strong>Q8. <code>useRef</code> provoque-t-il un re-rendu du composant quand sa valeur change ?</strong>
A) Oui
B) Non</p>
<p><strong>Q9. Dans quel fichier avons-nous centralis√© la logique d'auth ?</strong>
A) <code>src/hooks/useAuth.ts</code>
B) <code>src/context/AuthContext.tsx</code>
C) <code>src/App.js</code></p>
<p><strong>Q10. Que faut-il faire si le token est expir√© (401) ?</strong>
A) R√©essayer en boucle
B) D√©connecter l'utilisateur et le rediriger vers le Login
C) Ignorer l'erreur</p>
<hr />
<p><em>R√©ponses : 1B, 2A, 3B, 4B, 5B, 6B, 7B, 8B, 9B, 10B</em></p>
<script>
    mermaid.initialize({ startOnLoad: true });
</script>
</body>
</html>